# Билет 6
## Git (назначение, возможности, преимущества) и GitHub flow

## Ключевые особенности

* Главное отличие Git'а от любых других СКВ — это то, как Git смотрит на свои данные
    * Git считает хранимые данные набором слепков небольшой файловой системы
    * Каждый раз, когда вы фиксируете текущую версию проекта, Git, по сути, сохраняет слепок того, как выглядят все файлы проекта на текущий момент
    * Ради эффективности, если файл не менялся, Git не сохраняет файл снова, а делает ссылку на ранее сохранённый файл
* Почти все операции — локальные
    * Для совершения большинства операций в Git'е необходимы только локальные файлы и ресурсы
* Проверка целостности данных
    * Перед сохранением любого файла вычисляется контрольную сумму, которая становится индексом этого файла
    * невозможно изменить содержимое файла или каталога так, чтобы Git не узнал об этом
* Очень сложно заставить систему удалить данные или сделать что-то неотменяемое
    * Можно потерять еще не сохраненные данные, но как только они зафиксированы, их очень сложно потерять

## Назначение

* Использование в ИТ-проектах
    * Фундаментальный инструмент разработки
    *Также используется для: файлы конфигурации, документация, тестовые данные и пр.
* Нестандартные применения Git
    * Хранилище для веб-контента: GitHub pages
    * Легковесная база данных
    * Git можно использовать программно при помощи libgit2, практически из любого популярного языка

Типы состояний файла:

* Зафиксированный
    * файл уже сохранён в локальной базе
* Изменённый
    * файлы, которые поменялись, но ещё не были зафиксированы
* Подготовленный
    * изменённые файлы, отмеченные для включения в следующий коммит


Стандартный рабочий процесс:

1. Вы вносите изменения в файлы в своём рабочем каталоге
2. Подготавливаете файлы, добавляя их слепки в область подготовленных файлов
3. Делаете коммит, который берёт подготовленные файлы из индекса и помещает их в каталог Git'а на постоянное хранение


## Возможности

### Ветвление
Ветка в Git'е — это просто __указатель__ на один из коммитов

Преимущества ветвления:

* Уже рабочая, стабильная версия кода сохраняется.
* Различные новые функции могут разрабатываться параллельно разными программистами.
* Разработчики могут работать с собственными ветками без риска, что кодовая база поменяется из-за чужих изменений.
* В случае сомнений, различные реализации одной и той же идеи могут быть разработаны в разных ветках и затем сравниваться.
* Есть соглашение, что имя __`master`__ используется для ветки, указывающей на последнее актуальное состояние проекта.

### Удалённый доступ

* Удалённый доступ к репозиториям Git обеспечивается git-демоном, SSH- или HTTP-сервером
* TCP-сервис git-daemon входит в дистрибутив Git и является наряду с SSH наиболее распространённым и надёжным методом доступа
* Метод доступа по HTTP, несмотря на ряд ограничений, очень популярен в контролируемых сетях, потому что позволяет использовать существующие конфигурации сетевых фильтров

### Преимущества

* Скорость работы
* Возможность локальных коммитов
* Быстрый запуск нового репозитория (без конфигурации и т.д.)
* Прост в использовании


## GitHub flow

1. Содержимое ветви master всегда работоспособно (deployable).
2. Начиная работу над чем-то новым, ответвляйте от ветви master новую ветвь, имя которой соответствует её предназначению (например, «new-oauth2-scopes»).
3. Закоммитив в эту ветвь локально, отправляйте регулярно свою работу и в одноимённую ветвь на сервере.
4. Когда вам понадобится отзыв, или помощь, или когда вы сочтёте ветвь готовою ко слиянию, отправьте запрос на слияние.
5. После того, как кто-то другой просмотрел и одобрил фичу, вы можете слить вашу ветвь в ветвь master.
6. После того, как ветвь master пополнилась новым кодом, вы можете немедленно внедрить его на продакшен и вам следует сделать это.



## Бинарные модули. Внутренняя структура ELF и PE модулей.
__Исполняемый модуль__ — файл, содержащий программу в виде, в котором она может быть (после загрузки в память и настройки по месту) исполнена вычислительной машиной.

### Аппаратная вычислетельная машина

* Программа представлена в виде двоичного кода для процессора с конкретной архитектурой
* Программа выполняется на "железном" процессоре
* Исполняемый модуль зависит от ОС и архитектуры ВМ
* Примеры: CPU, GPU, DSP.

### Программная вычислетельная машина

* Программа может быть представлена в произвольном виде
* Программа выполняется внутри абстрактной виртуальной машины
* Выполняемый модуль не привязан к архитектуре аппаратной машины
* Модуль использует свою модель выполнения, м.б. отличной от аппаратной
* Примеры: JVM, Dalvik, .NET.

## Форматы исполняемых модулей

Формат определяет структуру модуля на диске и в памяти, а также правила его загрузки

* Примитивные, не переносимые:
    * являются дампом памяти и, как правило, отражают детали аппаратуры
    * пример: прошивки микроконтроллеров, ранние BIOS, COM файлы для CP/M и DOS
* Переносимые:
    * предназначены для стандартизированной среды исполнения
    * могут содержвть не только программу, но и статичные ресурсы
    * пример: NE, PE для OS Windows, COFF, ELF для Unix

## ELF модуль (Unix)

![](./pictures/Elf-layout.png)

ELF является основным файловым форматом во всех Unix-подобных операционных системах, при этом постепенно охватывая мобильные платформы

ELF был призван упростить и стандартизировать разработку, предоставляя программистам чёткую и понятную структуру файла

Любой файл состоит из:

* Заголовок файла:
    * Тип (исполнения или компоновки)
    * Архитектура аппаратной платформы
    * Аппаратно зависимые флаги
    * Точка входа
* Таблица заголовков сегментов
    * служит для описания сегментов файла
* Таблица заголовков секций
    * характеризует секции файла
* Данные сегментов и секций


__Сегмент__ - это непрерывная область адресного пространства со своими атрибутами доступа. В частности, сегмент кода имеет атрибут исполнения, а сегмент данных - атрибуты чтения и записи.

__Секция__ - фрагмент сегмента, имеющий определённое назначение:
  - .init (процедуры инициализации);
  - .plt (секция связок);
  - .text (основой код программы);
  - .fini (процедуры финализации).

Информация о сегментах используется при выполнении (Run-time).

Информация о секциях используются при компоновке (Link-time).
Исполняемые файлы, `*.so`, `*.a`, `*.o` файлы используют ELF формат.

## PE (Portable Executable) Модуль (Windows)

![](./pictures/Pe-layout.png)

__PE формат__ - формат исполняемых файлов всех 32- и 64- разрядных Windows систем. На данный момент существует два формата PE-файлов: PE32 и PE32+. PE32 формат для x86 систем, а PE32+ для x64

* Исполняемые файлы *.exe, динамические библиотеки *.dll и драйверы используют PE формат
* Формат несколько раз расширялся и некоторые функции могут быть реализованы по-разному
* Не все инструменты одинаково интерпретируют/генерируют PE файлы
* В PE модуле есть отдельная секция ресурсов
* Хорошая статья на Хабре с деталями: http://habrahabr.ru/post/266831/

Структура:

* MS DOS часть для совместимости
* PE заголовок
    * Архитектура аппаратной платформы
    * Аппаратно зависимые флаги
    * Подсистема Windows (GUI, CUI, OS/2, Posix)
    * Точка входа
    * Контрольная сумма
* Заголовки секций
* Данные секций
