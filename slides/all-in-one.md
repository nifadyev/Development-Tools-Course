# Билет №1
## Сравнительный анализ текстового и бинарного форматов.

## Текстовый формат
__Текстовый файл__ — компьютерный файл, содержащий текстовые данные,\
как правило, организованные в виде строк.

### Преимущества текстового формата

* __Воспринимаемость человеком__ — просто понять структуру и содержание, часто без документации и специальных инструментальных средств.
* __Простота__ — формат крайне удобен и его можно редактировать огромным количеством инструментов. И в первую очередь простым текстовым редактором.
*  __Версионируемость__ — файлы легко сравнивать, находить изменения.
*  __Переносимость__ — текстовый файл может быть прочитан на любой системе или ОС.
*  __Устойчивость__ — каждое слово и символ в таком файле самодостаточны и, если случится повреждение байтов в таком файле, то обычно можно восстановить данные или продолжить обработку остального содержимого.

### Недостатки текстового формата

* Увеличенный размер за счет разметки
* Долгое чтение 

В эпоху быстрых компьютеров и дешевой памяти эти преимущества побеждают.

## Бинарный формат

__Двоичный (бинарный) файл__ — в широком смысле: последовательность произвольных байтов.

### Преимущества бинарного формата

* __Минимальный размер__ — не содержат "разметки", часто являются сжатыми.
* __Машинное представление__ данных, иногда допускает прямую (а значит быструю) загрузку в оперативную память (например сериализованные структуры данных). Нет необходимости в конверсии.
*  __Эффективность__ некоторых операций: поиск элементов, иногда вставка и удаление.

### Недостатки бинарного формата

* Не воспринимается человеком
    * Иногда может быть плюсом, например в закрытых коммерческих проектах
* Плохая переносимость
    * На разных системах различные размеры типов данных (например, int в С/С++) и различные порядок байт в слове (big-endian, little-endian)

## Тестирование. Классификация тестов, критерии хорошего теста, инструменты.

__Тестирование программного обеспечения__ — процесс исследования, испытания программного продукта, имеющий своей целью проверку соответствия между реальным поведением программы и её ожидаемым поведением на конечном наборе тестов, выбранных определенным образом.

## Классификация тестов: по масштабу

![](./pictures/test-levels.png)

## Классификация тестов: по назначению

### __Функциональные требования__

* На задымление (smoke)

    * Первый прогон программы (после написания или после внесения существенных изменений). Как правило, используется для определения, готова ли программа для проведения более обширного тестирования. Целью является выявление проблем «лежащих на поверхности» – тестируется чаще всего основная бизнес логика программы
* Регрессионные (regression)
    * Повторное тестирование после внесения изменений в программное обеспечение или в его окружение (в новой версии приложения), чтобы убедиться в том, что функции, которые работали в предыдущей версии системы, по-прежнему работают так, как ожидалось, а найденные дефекты успешно исправлены (все протестированное ранее тестируется повторно). Целью является выявление потенциальных проблем, которые могли возникнуть в результате изменений. Проверка исправления найденных ранее дефектов.
* На точность (accuracy)
    * Проверка корректности результатов выполнения программы.
* Соответствие/совместимость (conformance/compliance)
    * Проверка скомбинированных компонентов прикладной программы с целью определения корректности их совместного функционирования. Целью является выявление потенциальных проблем в совместном функционировании компонент.
* Приемочные (acceptance)
    * Первый и самый короткий тест, призванный проводить проверку основных элементов программного продукта и его работоспособности в целом. Проверяется основной функционал приложения. На основе результатов данного теста принимается решение о приемке версии программного продукта и продолжении тестирования текущей версии продукта более серьезными тестовыми испытаниями.
* Функциональные (functional)
    * Проверка соответствия продукта функциональным требованиям и спецификациям.

### __Нефункциональные требования__

* На производительность (performance)
    * Проверка скорости работы системы (время отклика, частота транзакций и другие зависящие от времени) в имитационной и реальной средах. Целью - установить реальную производительность программного продукта.
* Стресс (stress)
    * Является одним из разновидностей тестирования на производительность. Проверяется поведение системы при недостатке ресурсов (дискового пространства, обрывов сети и т.д.). 
* Нагрузочные (load)
    * Это те же тесты производительности, при которых система подвергается различным нагрузкам; при этом цель этого тестирования – оценить способность системы правильно функционировать при некотором превышении планируемых нагрузок при реальной эксплуатации (система имеет некоторый «запас прочности»). Цель - Убедиться в том, что система работает соответственно ожидаемым рабочим нагрузочным параметрам (какой предел работоспособности).
* Качество кода (code quality)
    * Проверка кода на соответствие стандартам написания кода, принятым внутри команды.

## Критерии хорошего теста

* Короткий (имеет чистый код)
    * Возможно быстро понять что тестируется и при каких условиях
* Сфокусированный (только один assert)
    * Позволяет мгновенно находить ошибку в коде программы при его модификации
* Быстрый
    * Выполняется за конечное время (обычно за доли секундб зависит от сложности теста)
* Автоматический
    * Не требует участия разработчика для выполнения
* Независим от порядка исполнения и окружения
    * Не использует специфические возможности компилятора/IDE/OS и т.д.
* Использует паттерн AAA: Arrange, Act, Assert
    * Общепринятый стандарт написания тестов

## Инструменты тестирования

Значительно упрощают создание и запуск unit-тестов,
позволяют придерживаться единого стиля.

* xUnit — общее обозначение для подобных фреймворков.
Бесплатно доступны для большинства языков:

* C/C++: CUnit, CPPUnit, GoogleTest
* Java: JUnit
* .NET: NUnit

Встроены в современные языки:

* D, Python, Go

### Типичные возможности

* Удобное добавление тестов
    * Простая регистрация новых тестов
    * Набор функций-проверок (`assert`)
    * Общие инициализации и деинициализации
* Удобный запуск тестов
    * Пакетный режим
    * Возможность фильтрации тестов по именам
* Часто допускают интеграцию с IDE
* Генерация отчета в стандартном XML-формате
    * Возможность последующего автоматического анализа
    * Публикация на web-страницах проекта



# Билет 2
## Языки разметки (XML, YAML, JSON). Назначение, плюсы и минусы каждого из них.
__Язык разметки__ — набор символов или последовательностей, вставляемых в текст для передачи информации о его выводе или строении.

## XML (eXtensible Markup Language)

### Достоинства

* Распространённость
* Поддержка многими редакторами
* Поддержка многими языками программирования
* позволяет стандартизировать вид файлов-данных в виде текста, который будет понятен человеку
* поддержка Юникод
* возможность описания записей, списков, деревьев, форматированного текста
* описание структур и имен полей, как описание значения полей, иными словами – это самодокументируемый формат
* строго определенные требования к анализу и синтаксис, позволяющие быть простым, непротиворечивым и эффективным
* иерархическая структура подходит для описания любых документов, кроме видео и аудио файлов, растровых изображений, двоичных данных и сетевых структур данных

### Недостатки

* Плохо воспринимается человеком в исходнике
* Неудобно редактировать
* Довольно сложная грамматика (90 паттернов)
* Нет возможности поточной обработки
* Не совместим с бинарными данными
* избыточный синтаксис
* размер документа больше, чем документа в других форматах передачи текстовых данных
* для большого количества задач можно использовать более простые решения
* отсутствие общепринятой методологии
* неоднозначность моделирования

### Примеры использования

* Отчеты различных утилит (результаты тестирования)
* Сериализация структур данных
* Конфигурационные файлы (в том числе для построения)


## YAML (YAML Ain't Markup Language)

### Достоинства

* легко понятен человеку
* ориентирован на удобство ввода-вывода типичных структур данных многих языков программирования
* переносим между языками программирования
* выразительный и расширяемый
* лёгкий в реализации и использовании
* Поддержка поточной обработки

### Недостатки

* Крайне сложная грамматика (210 паттернов).
* Не совместим с бинарными данными
* содержит много пространств отступа
* не настолько популярен как XML или JSON
* для каждого языка приходится писать собственный парсер
* нельзя применять стандартные преобразования
* нельзя создавать составные документы

### Примеры использования

* Конфигурационные файлы
* Сериализованные данные

## JSON (JavaScript Object Notation)

### Достоинства

* распространённость
* поддержка многими редакторами
* поддержка многими языками программирования
* довольно простая грамматика (30 паттернов)
* функционально и синтаксически является подмножеством YAML
* скорость выполнения
* поддержка реляционных данных
* поддержка расширяемых типов данных помимо примитивов: строк, чисел, логических значений и т. д.
* расширяемость (увеличить данные легче, нежели чем в XML)
* наладка и налаживание погрешностей


### Недостатки
* безопасность (вызов eval())
* нет возможности поточной обработки 

### Примеры использования

* Cериализация структур, часто в веб-приложениях



## Google Test. Назначение, возможности (и unit-testing фреймворков вообще), использование.
## Краткая информация

* Популярный фреймворк для написания модульных тестов на С++ разработанный Google.
* Проект c BSD-лицензией (допускает использование в закрытых коммерческих проектах).
*. Используется в целом ряде крупных проектов
    * Chromium, LLVM компилятор, OpenCV
* Написан на C++, строится при помощи CMake
     * Поддерживает: Linux, Mac OS X, Windows, Cygwin, Windows CE и Symbian
* Как правило используется в консольном режиме, но существует вспомогательное GUI.

## Типичные возможности unit-testing фреймворков

* Удобное добавление тестов
    * Простая регистрация новых тестов
    * Набор функций-проверок (`assert`)
    * Общие инициализации и деинициализации
* Удобный запуск тестов
    * Пакетный режим
    * Возможность фильтрации тестов по именам
* Часто допускают интеграцию с IDE
* Генерация отчета в стандартном XML-формате
    * Возможность последующего автоматического анализа
    * Публикация на web-страницах проекта

## Возможности Google Test

* Автоматическое развервертывание тестов (Automatic test discovery)
* Большой набор assertions, возможность создавать пользовательские assertions (Rich set of assertions, user-defined assertions)
* "Смертельные" тесты (Death tests)
* Критические и некритические сбои (Fatal and non-fatal failures)
* Параметризуемые по типу или по значению тесты (Value- and type-parameterized tests)
* Различные опции по запуску тестов (Various options for running the tests)
* Генерация отчета в XML формате (XML test report generation)

## Порядок использования Google Test

* Каждый тест реализован как функция, с использованием макроса `TEST()` или `TEST_F()`.
    * `TEST()` не только определяет, но и "регистрирует" тест.
* Новые тесты добавляются в тот же test suite, их могут быть тысячи.
* При необходимости test suite разбивается на несколько
    * Корректность и производительность
    * Быстрый (pre-commit) и полный (ночной)

### Пример
```cpp
#include <gtest/gtest.h>

TEST(MathTest, TwoPlusTwoIsFour)
{
  EXPECT_EQ(2 + 2, 4);
}
```



# Билет №3
## Инструменты для обработки текста в командной строке. Назначение, возможности, преимущества.

## Просмотр

### cat/tac

* `cat` (catenate) позволяет создавать, копировать, сливать и отображать текстовые файлы
* `tac` делает то же самое, но в обратном порядке
    * файл просматривается не с начала, а с конца
    * крайне удобно при просмотре логов и различных отчетов

#### Примеры использования

* cat file1 file2 - вывод нескольких файлой
* cat file1 file2 > file3 - обЪединение файлов
* cat >file - создание файла

### head/tail

* `head` позволяет просмотреть начало файла (по умолчанию первые 10 строк)
    * полезна при необходимости просмотреть начало крайне большого файла, так как не загружает весь файл, а лишь его часть
    * удобна, если, например, необходимо просмотреть заголовок файла видео контента
* `tail` позволяет просмотреть последние строки файла (по умолчанию первые 10 строк)
    * экономит уйму времени на прокрутке в самый конец и загрузке большого файла
    * используется для проверки логов, журналов и отчетов

#### Примеры использования

* head file - вывести первые 10 строк файла
* tail file - вывести последние 10 строк файла

### less

* `less` используется для просмотра (но не изменения) содержимого текстовых файлов
* отображает файл с возможностью прокрутки
* возможна обратная прокрутка
* не нуждается в чтении всего файла перед стартом
    * быстрее работает с большими файлами

#### Примеры использования

* less /dir/file1 file2incurrentdir /dir3/file3 - открытие нескольких файлов

## Поиск

### grep

 * `grep` (global regular expression print) используется для поиска строк, соответствующих строке в тексте или содержимому файлов
 * может находить по шаблону или регулярным выражениям
 * позволяет выводить на консоль или в файл найденные строки/выражения/файлы

#### Примеры использования

* `grep -nIHR "^#" --include=*.md ./` - вывод всех заголовков в Markdown файлах ("`| wc -l`" добавит их подсчет)
* `grep -nIHR "class.*Matcher" --include=*.hpp -B1 ./` - печать деклараций всех классов, содержащих слово Matcher (+одна строка до)

## Обработка

### sed
* `sed` (Stream EDitor) редактирует поток данных для автоматического редактирования текстов
* вначале загружает в себя набор команд, а затем применяет весь набор команд к каждой строчке текста
* позволяет выполнять такие операции как добавление, вставка, удаление или замена
* может находить по шаблону или регулярным выражениям
* тьюринг-полный язык программирования

#### Примеры использования

* `sed 's/foo/bar/g'` — заменяет foo на bar
* `sed '/baz/s/foo/bar/g'` — то же самое, но если строка содержит baz
* `sed 's/[ \t]*$//'` — удалить "висячие" пробельные символы
* `sed '/regex/G'` — вставить пустую строку под каждой, содержащей "regex"
* `sed 'n;n;n;n;G;'` — вставить пустую строку через каждые 5
* `sed -n '$='` — посчитать количество строк
* `sed '1,10d'` — удалить первые 10 строк файла

### awk

* `awk` (Authors: Aho, Weinberger, Kernighan) - язык программирования со своими собственными правилами
* утилита для извлечения данных
* читает за один раз одну строку, выполняет определенные действия в зависимости от заданных опций, и выводит результат
* позволяет выполнить выбор столбца из текстового файла или из вывода другой команды
* содержит внутренние функции для математических вычислений, работы со строками, управления обменом данных и форматирования текста

#### Примеры использования

* `awk '{print NR "\t" $0}'` — распечатать файл с номерами строк
* `awk 'END{print NR}'` — вывести число строк в файле
* `awk '{print $2, $1}'` — распечатать второе и первое поле в обратном порядке
* `awk '{s=0; for (i=1; i<=NF; i++) s=s+$i; print s}'` — вывести сумму полей для каждой строки
* `awk '{sub(/[ \t]+$/, "")};1'` — удалить "висячие" пробельные символы
* `awk '{l=length();s=int((79-l)/2); printf "%"(s+l)"s\n",$0}' filename` — центрировать и распечатать файл


## Непрерывная интеграция. Назначение, преимущества, эволюция подходов, реализация.

__Непрерывная интеграция__ (англ. Continuous Integration) — это практика разработки ПО, которая заключается в выполнении частых автоматизированных сборок проекта для скорейшего выявления и решения интеграционных проблем.

## Назначение

Переход к непрерывной интеграции позволяет **снизить трудоёмкость** интеграции и сделать её более **предсказуемой** за счет наиболее раннего обнаружения и устранения ошибок и противоречий

* Каждое изменение должно интегрироваться
* Слово continuous в термине Continuous Integration означает «непрерывный/непрекращающийся»
    * Это означает, что в идеале сборка вашего проекта должна идти буквально все время
* Организация ночных сборок — это хорошая практика, но это не continuous integration
    * Ведь результаты такой ночной сборки будут доступны лишь на следующий день, когда их актуальность для разработчиков уже значительно снижена
* Принцип непрерывной интеграции не выполним без условия — «Сборка должна идти быстро».

## Преимущества

* основным преимуществом является сокращение стоимости исправления дефекта, за счёт раннего его выявления
* в __центральном репозитории__ есть абсолютно все, что нужно для сборки: исходный код, конфигурационные файлы, тестовые данные, сборочные и тестовые скрипты.
* __полная автоматизация__ операций с кодом: выкачивание из репозитория, сборка, тестирование и так далее.
* в первую очередь это безболезненная интеграция всего проекта. Интеграция различных модулей и правок происходит «сама» без участия людей и если что-то не так, вы об этом узнаете.
* если что-то не работает на сборочном сервере — значит оно не работает вообще. Сервер интеграции становится судьей в таких вопросах и этот судья беспристрастен.
* постоянное наличие текущей стабильной версии вместе с продуктами сборок — для тестирования, демонстрации, и т. п.
* все анализаторы кода и тесты, которые вы используете и написали, обязательно запускаются над каждой сборкой. Если в систему контроля версий попал «плохой» код — вы об этом узнаете.

## Эволюция подходов

* __Waterfall__: разделить на компоненты, реализовать, интеграция — отдельная фаза
* __Nightly build ('90s)__: интегрироваться часто, ночной билд (heartbeet of the project)
* __Continuous Integration ('00s)__: интегрироваться непрерывно, тестирование каждого вливания
* __Pre-commit Testing ('10s)__: интегрироваться непрерывно, но после проверки (основной подход на сегодняшний день) стабильности
* __Continuous Deployment ('10s)__: развертываться непрерывно, сразу после проверки стабильности

## Реализация

### Требования к проекту

* Исходный код и всё, что необходимо для сборки и тестирования проекта, хранится в центральном репозитории
* Операции копирования из репозитория, сборки и тестирования всего проекта автоматизированы и легко вызываются из внешней программы
* Реализация выполняется специальным сервером (Travic, BuildBot)



# Билет №4
## Регулярные выражения. Назначение, синтаксис, примеры реализаций и использования

__Регулярные выражения__ (англ. regular expressions) — формальный язык поиска
и осуществления манипуляций с подстроками в тексте, основанный на использовании
метасимволов (англ. wildcard characters).

По сути это строка-образец (англ. pattern, по-русски её часто называют «шаблоном», «маской»), состоящая из символов и метасимволов, и задающая правило поиска.

Метасимволы: `[ ] \ / ^ $ . | ? * + ( ) { }`

## Синтаксис

* Обычные строки обозначают сами себя
* `.` — может быть использована вместо любого символа
* `\` — экранирует метасимволы (`/` иногда используется как разделитель)
* `( )` — группировка, указывает приоритет операций
* `[ ]` — обозначает символьный класс (`[abc], [0123456789], [а-я], [0-9]`)
* `^ $` — указывают на начало и конец строки
* `? * + { }` — указывают число повторений

## Примеры регулярных выражений

* `polynomial`
* `3\.1415926`
* `static`
* ` static .*(.*;`
* `^class`
* `[0-9]{6}`


## Сервера непрерывной интеграции. Задачи и примеры, сравнительный анализ систем

## Задачи выделенного сервера

* Получение исходного кода из репозитория
* Сборка проекта (в том числе построение дистрибутивов)
* Выполнение тестов и автоматических проверок
* Отправка отчетов (хранение истории и статистики)
* Развёртывание готового проекта

## Travis CI

* Распределённый веб-сервис для сборки и тестирования программного обеспечения, использующий GitHub в качестве хостинга исходного кода
* Программная составляющая сервиса также располагается на GitHub’е, однако разработчики не рекомендуют использовать её в закрытых проектах
* Веб-сервис для сборки и тестирования ПО (open-source)
* Важными особенностями являются интеграция с GitHub и возможность бесплатного использования
* Поддерживает большое количество языков: C, C++, Java, JavaScript, Python
* Тестирование происходит на виртуальных Linux-машинах, запускаемых в облаке Amazon (Amazon S3)

## BuildBot

* Инструмент непрерывной интеграции
* Используется в ряде крупных проектов: Chromium, WebKit, Firefox, Python, OpenCV
* Реализован на Python, как результат переносим и допускает кастомизацию (программирование билдеров)
* Проект разрабатывается на GitHub, тестируется при помощи Travis CI


# Билет №5
## СКВ. Основные функции и термины, базовые принципы

__Системы контроля версий__ — это программные системы, хранящие несколько версий одного документа, и позволяющие вернуться к более ранним версиям. Как правило, для каждого изменения запоминается дата модификации и автор.

## Функции

* История изменений
    * Откат дефектных изменений
    * Извлечение кода "из прошлого"
    * Поиск ошибок сравнением
* Централизованное хранение
    * Актуальное и используемое всеми участниками
    * Защищенное, с разграничением прав доступа

## Термины

* __Рабочая директория__ (Working Directory)
    * Рабочая директория – это место, где файлы проверяются. Git не отслеживает каждый изменённый файл
    * Когда мы выполняем операцию commit, Git ищет все файлы, которые находятся в рабочей директории
    * Подтверждаются только те файлы, которые в ней находятся
* __Локальный репозиторий__ (Local Repository)
    * Личное рабочее пространство для работы с проектом
    * Разработчик вносит изменения в проект в этом репозитории и, после подтверждения изменений, они становятся частью локальной копии
    * Пользователь может выполнить множество изменений, которые будут храниться только на его машине до тех пор, пока он не отправит их в центральный репозиторий
* __Дерево__ (Tree)
    * Объект, который представляет собой директорию
    * Хранит бинарные большие объекты как под-директории
    * Дерево – это бинарный файл, который хранит ссылки на, так называемые, Blobs и деревья, которые представлены SHA1 хэшем объекта дерева.
* __Бинарный Большой Объект__  (Blob или Binary Large Object)
    * Файл, который представляет версию файла
    * Содержит данные файла, но не хранит его метаданные
    * Это двоичный объект и в базе данных Git он называется SHA1 хэшем файла
    * В Git доступ к файлам обеспечивается не по имени, а по содержанию.
* __Коммит__ (Commit)
    * Хранит текущее состояние репозитория 
    * Также называется SHA1 хэшем
    * Можно представить, что commit – это элемент связного списка
        * Каждый такой элемент имеет ссылку на родительский элемент
        * Из этого элемента мы можем откатиться назад с помощью ссылки на предыдущий элемент для того
    * Если у коммита есть несколько родительских коммитов, то это означает, что он был создан путём слияния двух ветвей
* __Клон__ (Clone)
    * Экземпляр репозитория
    * Не только проверяет рабочую копию, но также становится хранилищем самого репозитория (зеркалом – mirror)
    * Разработчик может выполнять множество операций на локальной машине, а после подключения к сети все данные могут быть синхронизированы
* __Ветвь__ (Branch)
    * Ветви используются для создания отдельной версии разработки
    * По умолчанию, Git имеет главную ветвь, которая называется master
    * При необходимости реализовать какой-либо функционал, или исправить ошибку, создаётся отдельная ветвь и выполняется необходимую работу
    * После того как задача выполнена, выполняется слияние с веткой master/development и ненужная ветвь удаляется
    * Это позволяет всегда хранить рабочую версию проекта и вносить уже полностью готовые и протестированные изменения в основную ветвь
* __Pull__ (Вытягивать)
    * Копирование всех изменений из удалённого репозитория на локальную машину
    * Используется для синхронизации локального репозитория с центральным
* __Push__ (Толчок)
    * Копирует изменения из локального репозитория в удалённый
    * Используется для синхронизации центрального репозитория с локальным
* __Заголовок__ (HEAD)
    * Ссылка, которая всегда указывает на крайний коммит ветви
    *  Когда мы выполняем операцию commit, HEAD обновляется и переводится на крайний коммит

## Базовые принципы

* Каждому проекту следует выработать свой рабочий процесс и правила именования веток. При этом желательно основываться на популярных подходах
* Приложение строится только на на основе известного состояния репозитория
    * Не только релизы, но и экспериментальные и тестовые сборки (builds)
    * В идеале приложение умеет сообщать свою ревизию и параметры сборки
* Стабильность общих (публичных) веток
    * Они обязаны компилироваться и проходить все тесты в любой момент времени
    * Изменения тестируются до попадания в репозиторий
    * Если дефектные изменения прошли, они исправляются в срочном порядке
* Абсолютно вся разработка фиксируется в истории
    * Это делается в виде отдельных веток локального или глобального репозитория
    * "Удачные" изменения добавляются в основную ветвь
* Публичная история проекта не "переписывается"
    * Однажды помеченные тэгами и выпущенные релизы модификации не подлежат
    * Промежуточная история не переписывается, потому что будут конфликты

## Понятие API, совместимости на уровне исходных кодов и бинарной, критерии и рекомендации

__API__ (Application Programming Interface) — набор готовых классов, процедур, функций, структур и констант, предоставляемых ОС, приложением, библиотекой для использования во внешних программных продуктах.

__Совместимость на уровне API__ — совместимость на уровне исходного кода на языке программирования. Замена библиотеки на другую не ломает компиляцию и логику программы.

__ABI__ (Application Binary Inerface) — бинарный интерфейс программ и библиотек, включающий в себя соглашения о вызовах, передаче параметров, обработке исключений и других сущностей языков программирования.

__Бинарная совместимость__ — совместимость на уровне скомпилированных модулей. Модуль можно заменить другим без потерь.

* Все современные ОС предоставляют API
* Все прикладные приложения явно или косвенно от него зависят
* Необходимо поддерживать совместимость

### Способы реализации API & ABI

* Программные прерывания процессора
* Динамическая компоновка и вызов библиотечных функции
* Формирование пакетов данных соответствующих общим соглашениям, протоколы



# Билет 6
## Git (назначение, возможности, преимущества) и GitHub flow

## Ключевые особенности

* Главное отличие Git'а от любых других СКВ — это то, как Git смотрит на свои данные
    * Git считает хранимые данные набором слепков небольшой файловой системы
    * Каждый раз, когда вы фиксируете текущую версию проекта, Git, по сути, сохраняет слепок того, как выглядят все файлы проекта на текущий момент
    * Ради эффективности, если файл не менялся, Git не сохраняет файл снова, а делает ссылку на ранее сохранённый файл
* Почти все операции — локальные
    * Для совершения большинства операций в Git'е необходимы только локальные файлы и ресурсы
* Проверка целостности данных
    * Перед сохранением любого файла вычисляется контрольную сумму, которая становится индексом этого файла
    * невозможно изменить содержимое файла или каталога так, чтобы Git не узнал об этом
* Очень сложно заставить систему удалить данные или сделать что-то неотменяемое
    * Можно потерять еще не сохраненные данные, но как только они зафиксированы, их очень сложно потерять

## Назначение

* Использование в ИТ-проектах
    * Фундаментальный инструмент разработки
    *Также используется для: файлы конфигурации, документация, тестовые данные и пр.
* Нестандартные применения Git
    * Хранилище для веб-контента: GitHub pages
    * Легковесная база данных
    * Git можно использовать программно при помощи libgit2, практически из любого популярного языка

Типы состояний файла:

* Зафиксированный
    * файл уже сохранён в локальной базе
* Изменённый
    * файлы, которые поменялись, но ещё не были зафиксированы
* Подготовленный
    * изменённые файлы, отмеченные для включения в следующий коммит


Стандартный рабочий процесс:

1. Вы вносите изменения в файлы в своём рабочем каталоге
2. Подготавливаете файлы, добавляя их слепки в область подготовленных файлов
3. Делаете коммит, который берёт подготовленные файлы из индекса и помещает их в каталог Git'а на постоянное хранение


## Возможности

### Ветвление
Ветка в Git'е — это просто __указатель__ на один из коммитов

Преимущества ветвления:

* Уже рабочая, стабильная версия кода сохраняется.
* Различные новые функции могут разрабатываться параллельно разными программистами.
* Разработчики могут работать с собственными ветками без риска, что кодовая база поменяется из-за чужих изменений.
* В случае сомнений, различные реализации одной и той же идеи могут быть разработаны в разных ветках и затем сравниваться.
* Есть соглашение, что имя __`master`__ используется для ветки, указывающей на последнее актуальное состояние проекта.

### Удалённый доступ

* Удалённый доступ к репозиториям Git обеспечивается git-демоном, SSH- или HTTP-сервером
* TCP-сервис git-daemon входит в дистрибутив Git и является наряду с SSH наиболее распространённым и надёжным методом доступа
* Метод доступа по HTTP, несмотря на ряд ограничений, очень популярен в контролируемых сетях, потому что позволяет использовать существующие конфигурации сетевых фильтров

### Преимущества

* Скорость работы
* Возможность локальных коммитов
* Быстрый запуск нового репозитория (без конфигурации и т.д.)
* Прост в использовании


## GitHub flow

1. Содержимое ветви master всегда работоспособно (deployable).
2. Начиная работу над чем-то новым, ответвляйте от ветви master новую ветвь, имя которой соответствует её предназначению (например, «new-oauth2-scopes»).
3. Закоммитив в эту ветвь локально, отправляйте регулярно свою работу и в одноимённую ветвь на сервере.
4. Когда вам понадобится отзыв, или помощь, или когда вы сочтёте ветвь готовою ко слиянию, отправьте запрос на слияние.
5. После того, как кто-то другой просмотрел и одобрил фичу, вы можете слить вашу ветвь в ветвь master.
6. После того, как ветвь master пополнилась новым кодом, вы можете немедленно внедрить его на продакшен и вам следует сделать это.



## Бинарные модули. Внутренняя структура ELF и PE модулей.
__Исполняемый модуль__ — файл, содержащий программу в виде, в котором она может быть (после загрузки в память и настройки по месту) исполнена вычислительной машиной.

### Аппаратная вычислетельная машина

* Программа представлена в виде двоичного кода для процессора с конкретной архитектурой
* Программа выполняется на "железном" процессоре
* Исполняемый модуль зависит от ОС и архитектуры ВМ
* Примеры: CPU, GPU, DSP.

### Программная вычислетельная машина

* Программа может быть представлена в произвольном виде
* Программа выполняется внутри абстрактной виртуальной машины
* Выполняемый модуль не привязан к архитектуре аппаратной машины
* Модуль использует свою модель выполнения, м.б. отличной от аппаратной
* Примеры: JVM, Dalvik, .NET.

## Форматы исполняемых модулей

Формат определяет структуру модуля на диске и в памяти, а также правила его загрузки

* Примитивные, не переносимые:
    * являются дампом памяти и, как правило, отражают детали аппаратуры
    * пример: прошивки микроконтроллеров, ранние BIOS, COM файлы для CP/M и DOS
* Переносимые:
    * предназначены для стандартизированной среды исполнения
    * могут содержвть не только программу, но и статичные ресурсы
    * пример: NE, PE для OS Windows, COFF, ELF для Unix

## ELF модуль (Unix)

![](./pictures/Elf-layout.png)

ELF является основным файловым форматом во всех Unix-подобных операционных системах, при этом постепенно охватывая мобильные платформы

ELF был призван упростить и стандартизировать разработку, предоставляя программистам чёткую и понятную структуру файла

Любой файл состоит из:

* Заголовок файла:
    * Тип (исполнения или компоновки)
    * Архитектура аппаратной платформы
    * Аппаратно зависимые флаги
    * Точка входа
* Таблица заголовков сегментов
    * служит для описания сегментов файла
* Таблица заголовков секций
    * характеризует секции файла
* Данные сегментов и секций


__Сегмент__ - это непрерывная область адресного пространства со своими атрибутами доступа. В частности, сегмент кода имеет атрибут исполнения, а сегмент данных - атрибуты чтения и записи.

__Секция__ - фрагмент сегмента, имеющий определённое назначение:
  - .init (процедуры инициализации);
  - .plt (секция связок);
  - .text (основой код программы);
  - .fini (процедуры финализации).

Информация о сегментах используется при выполнении (Run-time).

Информация о секциях используются при компоновке (Link-time).
Исполняемые файлы, `*.so`, `*.a`, `*.o` файлы используют ELF формат.

## PE (Portable Executable) Модуль (Windows)

![](./pictures/Pe-layout.png)

__PE формат__ - формат исполняемых файлов всех 32- и 64- разрядных Windows систем. На данный момент существует два формата PE-файлов: PE32 и PE32+. PE32 формат для x86 систем, а PE32+ для x64

* Исполняемые файлы *.exe, динамические библиотеки *.dll и драйверы используют PE формат
* Формат несколько раз расширялся и некоторые функции могут быть реализованы по-разному
* Не все инструменты одинаково интерпретируют/генерируют PE файлы
* В PE модуле есть отдельная секция ресурсов
* Хорошая статья на Хабре с деталями: http://habrahabr.ru/post/266831/

Структура:

* MS DOS часть для совместимости
* PE заголовок
    * Архитектура аппаратной платформы
    * Аппаратно зависимые флаги
    * Подсистема Windows (GUI, CUI, OS/2, Posix)
    * Точка входа
    * Контрольная сумма
* Заголовки секций
* Данные секций



# Билет №7
## Автоматизация. Преимущества, способы реализации, примеры

__Автоматизация__ — одно из направлений научно-технического прогресса, использующее саморегулирующие технические средства и математические методы с целью освобождения человека от участия в процессах получения, преобразования, передачи и использования информации, либо существенного уменьшения степени этого участия или трудоёмкости выполняемых операций.

## Преимущества автоматизации

* Мощность / повышение уровня абстракции
    * Фокус на основной задаче
    * Меньшее количество переключений контекста
* Надежность
    * Отсутствие человеческого фактора
* Скорость
* Дешевизна
    * Особенно при многократном запуске
* Освобождение времени

> Главное: концентрация на том, что __действительно__ важно.

## Автоматизация в деятельности программиста

* Сбор и обработка данных
    * Составление отчетов/графиков, анализ и обработка больших массивов данных
* Тестирование
    * Изменения ничего не сломали, анализ производительности
* Администрирование
    * Регулярные процедуры (бэкап), сложное конфигурирование
* Собственно автоматизация
    * Построение дистрибутивов, развертывание

## Пример автоматизации

### Контекст

* Вы занимаетесь сбором тестовых данных для компании,\
    разрабатывающей ПО для предсказания популярности видео-роликов про котов.
* Входными данными для программы-классификатора являются:
    * _черно-белые кадры_ ролика
    * разрешением _320х240_
    * сохраненные покадрово в формате _JPEG_
* Программе обучения требуется также знать:
    * _дату загрузки_ видео
    * _количество просмотров_ на начало каждого дня

### Простор для автоматизации

* Что является неавтоматизируемой частью работы?
    * Выбор роликов про котов
* Что является автоматизируемой частью работы?
    * Всё остальное

### Как должен выглядеть рабочий процесс?

* В течение рабочего дня вы просматриваете ролики на YouTube в поисках
    интересных роликов про котов.
* Подходящие ролики скачиваются, обрабатываются и добавляются в базу — одним
    нажатием кнопки.
* В начале каждого дня для каждого ролика в базу добавляется текущая
    информация о количестве просмотров, без вашего участия.

## Ключевые моменты

* Компьютерные системы имеют огромнейшие возможности для автоматизации — ими нужно овладеть и пользоваться.
* Автоматизированные шаги становятся вашими инструментами, используя которые вы можете решать более сложные задачи быстрее.

> Главное: деятельность профессионала заключается в поиске автоматизируемых
> частей и, собственно, их автоматизации.


## Отладка. Назначение, методы, алгоритм "волчья ограда"

**Отладка** - это процесс нахождения и устранения ошибок и дефектов в компьютерной программе или в электронном оборудовании.

**Отладчик** - это компьютерная программа, которая используется для тестирования и отладки других программ.

### Инструменты отладки

* **GDB**: GNU отладчик
* **Valgrind**: утилита для отладки проблем с памятью, утечек памяти и
    профилирования
* **strace**: трассирование системных вызовов
* **OProfile**: профилировщик для Linux систем

## Назначение отладки

Обнаружение, локализация и исправление ошибок в программе.

## Методы отладки

* Printf отладка, трассирование и логирование
    * Вывод основных значимых данных (аргументы функций, состояния переменных, стека, памяти и т.д.) в файл или консоль
* Post-mortem отладка (дамп памяти, логи) 
    * Разновидность логирования, в которой логируется вся память целиком (состояние процесса и регистров, когда возникает exception)
    * Помогает "раскрутить" состояние программы, в котором она находилась во время падения 
    * https://habr.com/post/89220/
    * «Для тех кто не знает что такое post-mortem, то это режим в котором отладчик стартует сразу после необработанного исключения.»
* Использование специальных программ (отладчиков)
    * Пошаговая отладка с просмотром состояний стека, переменных, памяти и т.д. в требуемых точках исполнения программы
* Проверка различных утверждений в коде (assert)
    * Проверка возвращаемых значений функций, вызова exception во время исполнения и изменения состояния зависимой от выполняемой функции среды
    * https://habr.com/post/141080/

## Алгоритм "волчья ограда"

* Сначала разделяем код пополам одним printf’ом
* В зависимости от того, был вывод printf’а или нет, определяем, в какой половине кода была ошибка
* Затем так же разделяем найденную половину пополам, чтобы определить более точное местонахождение ошибки
* В итоге итерировано продолжаем разделять код, пока не дойдем до уровня функций



# Билет №8

## Markdown. Назначение, синтаксис, примеры использования.

* Облегчённый язык разметки, созданный с целью написания наиболее читаемого и удобного для правки текста, но пригодного для преобразования в языки для продвинутых публикаций (HTML, Rich Text и других)
* Вероятно, самый популярный из легковесных языков разметки на сегодняшний день
* Используется на StackOverflow и GitHub в качестве языка для wiki и комментариев
* Поддерживается редакторами, оброс большим количеством инструментов
* Минус: встречаются расхождения в "толковании"
    * Но уже есть CommonMark!

## Синтаксис

* Заголовки
    * Для того чтобы написать заголовок в Markdown, необходимо использовать знак # (хэш)
    * Если необходимо несколько уровней заголовков, нужно изменить количество хэшей (#) перед текстом заголовка

    ```
    # H1
    ## H2
    ### H3
    ```

    * Альтернативные теги для H1 и H2 (знаки равно или минусы под заголовком + пустая строчка над загаловком):

    ```
    Альтернативный-H1
    ======

    Альтернативный-H2
    ------
    ```

* Списки
    * Markdown поддерживает два вида списков: маркерованный и нумерованный
    * Для организации маркерованного списка используются знаки *, + и -. От них зависит вид маркеров
    * Чтоб сделать многоуровневый список, нужно будет сделать отступы (4 или 8 пробелов).
```
1. Первый пункт списка
2. Второй пункт
⋅⋅⋅* Немаркерованный вложенный подпункт. 
1. Номер не имеет значения, нужно чтобы это была просто любая цифра
⋅⋅⋅1. Маркерованный вложенный подпункт.
4. Тут другой пункт.

⋅⋅⋅Можно вставлять в список отдельный абзац. Но, обратите внимание на пустую строчку сверху и пробелы перед строчкой.

⋅⋅⋅Чтобы вставить абзац без пустой строчки сверху, нужно в конце строки поставить два пробела.⋅⋅
⋅⋅⋅Обратите внимания что эта строчка отдельная, хотя находится в том же абзаце.⋅⋅
⋅⋅⋅В этой строчке пробелы в конце строчки не требуются.

* Для ненумерованных списков можно использовать звёздочки
- Или минусы
+ Или плюсы
```

* Горизонтальные линии
    * Создать горизонтальную линию можно поместив три или больше звездочек *, минусов — или подчеркиваний _ на отдельной строке.

    ```
    ***
    ```

    * Можно разделять символы пробелами, чтобы сделать линию более очевидной в процессе редактирования документа

    ```
    * * * * *  
    -------------------------  
    _ _ _ _ _  
    ```

    * Каждая из приведенных выше строк даст одинаковый результат


* Абзацы, параграфы
    * В маркдаун все блочные элементы (заголовки, списки, абзацы и т.д.) — все, что визуально начинается с новой строки отбивается пустой строкой


* Перенос строки
    * Перенос строки всегда игнорируется
    * Это делается для того, чтобы, например, была возможность при наборе держать определенную длину строки, скажем в 80 символов.
    * Т.к. Markdown создавался с целью быть удобночитаемым, его нередко используют в текстовых документах и для комфорта читателя лучше не давать тексту расплываться соплёй по экрану.
    * Для переноса строки внутри абзаца нужно использовать __два пробела__ в конце строки.


* Курсивное и жирное выделение текста
    * Для курсива необходимо поставить знаки * вокруг текста
    * Для жирного начертания обрамим текст двумя звездочками, а для жирного курсива — тремя
    * Альтернативный синтаксис — использование знака _ по тем же правилам

```
___жирный курсив___
```


* Выделение текст или код
    * Выделить текст или часть кода можно с помощью символа гравис (обратный апостроф) `

* Отмена форматирования
    * Если вы хотите, чтобы введенные теги HTML, код, теги маркдауна отображались в точности как вы их написали, то начните каждую строку с четырех пробелов.

⋅⋅⋅⋅тут должен быть **жирный текст**, но я поставил 4 пробела в начале строки

* Цитаты
Для обозначения цитат достаточно поставить знак > в начале строки

```
> Это простая цитата⋅⋅  
Состоящая из двух строк
```

* Ссылки
    * Существует два варианта оформления ссылок
        * Первый — обычная вставка в текст

        ```
        [Текст ссылки](адрес "Описание")
        ```
        * Второй вариант — оформление ссылки в виде сноски. Тогда в текст вставляется конструкция, указывающая, что именно в этом место будет располагаться ссылка, а где-нибудь ниже её описание

        ```
        [Текст ссылки][Тег1]
        ```

* Сноски
    * Сноски и примечания1 задаются так2:

```
Сноски и примечания[^1] задаются так[^2]:
// пустая строка обязательно
[^1]: Все сноски отображаются в конце страницы
[^2]: Просто не так ли?)
```

* Изображения
    * Изображения помещаются на страницу также, как и ссылки, с одним отличием: в начале записи используется знак !

```
![Alt-текст](Путь к файлу "Подпись")
```

* Таблицы
    * Создание таблиц с Markdown намного нагляднее, чем в HTML
    * Форматирование интуитивно понятно, для выравнивания текста внутри ячеек используются знаки : в строке, отделяющей заголовок от основной таблицы

```
Item      | Value | Quantity
:-------- |:-----:| -------:
Computer  | 1600  | 3
Phone     | 12    | 2
Pipe      | 1     | 1
Item | Value | Quantity
:——— |:——:| ——-:
Computer | 1600 | 3
Phone | 12 | 2
Pipe | 1 | 1
```

* Спецсимволы
    * Если вы хотите отобразить любой из специальных символов Markdown вместо того, чтобы использовать его для форматирования, просто поставьте перед ним символ обратной косой черты (\). 
    * Сама косая черта не отображается, однако следующий за ней символ будет показан как есть:


* Списки определений
    * Списки определений содержат термины и их описания
    * Это выглядит подобно словарю

```
Moodle
:   Хорошо известная платформа для онлайнового обучения

PHP
:   Язык программирования.
    Часто используется для разработки интерактивных веб-приложений.
```

* Спойлер
    * Скрывает большие объемы текстовой и графической информации с помощью Advanced Spoiler, который уже 2 года не обновляется и работает не везде.

```
[spoiler]тут текст[/spoiler]
[spoiler]тут текст[/spoiler]
```

## Примеры использования Markdown

  1. GitHub: wiki and comments using GFM.
  2. StackOverflow: questions and answers [editing](http://stackoverflow.com/editing-help).
  3. Askbot: the same as StackOverflow.



## ИСР. Назначение, состав, возможности.

__Интегрированная среда разработки__, ИСР (англ. IDE, Integrated development environment или integrated debugging environment) — система программных средств, используемая программистами для разработки программного обеспечения.

## Основные модули IDE

* Текстовый редактор
* Компилятор и/или интерпретатор
* Средства автоматизации сборки
* Отладчик

## Функции современных IDE

* Автодополнение кода
* Поддержка шаблонов проектов
* Сниппеты
* Поддержка систем контроля версий
* Интеграция задач (//TODO: ...)
* Браузер классов
* Визульное редактирование классов
* Инструменты рефакторинга
* Профилировщик
* Работа с СУБД, веб-сервисами

### При традиционном подходе, начальный этап написания программы строится следующим образом:

1. Исходный текст набирается при помощи какого-либо текстового редактора.
2. По завершении набора, работа с текстовым редактором прекращается и запускается кросс компилятор.
3. Как правило, вновь написанная программа содержит синтаксические ошибки, и компилятор сообщает о них на консоль оператора.
4. Вновь запускается текстовый редактор, и оператор должен найти и устранить выявленные ошибки, при этом сообщения о характере ошибок выведенные компилятором уже не видны, так как экран занят текстовым редактором.

### Работа в интегрированной среде дает программисту:

1. Возможность использования встроенного многофайлового текстового редактора, специально ориентированного на работу с исходными текстами программ;
2. Иметь автоматическую диагностику выявленных при компиляции ошибок, когда исходный текст программы, доступный редактированию, выводится одновременно с диагностикой в многооконном режиме;
3. Возможность параллельной работы над несколькими проектами. Менеджер проектов позволяет использовать любой проект в качестве шаблона для вновь создаваемого проекта;
4. Минимум перекомпиляции. Ей подвергаются только редактировавшиеся модули;
5. Возможность загрузки отлаживаемой программы в имеющиеся средства отладки, и возможность работы с ними без выхода из оболочки;
6. Возможность подключения к оболочке практически любых программных средств.



# Билет №9
## Текстовые редакторы. Возможности, сравнительный анализ популярных редакторов

__Текстовый редактор__ — самостоятельная компьютерная программа или компонент программного комплекса (например, редактор исходного кода интегрированной среды разработки или окно ввода в браузере), предназначенная для создания и изменения текстовых данных в общем и текстовых файлов в частности.

## Важные свойства редакторов

* Кросс-платформенность
* Настраиваемость
    * Шрифты, оформление, клавиатурные комбинации
* Расширяемость
    * Новые языки программирования и форматы файлов
* Программируемость
    * Программируемость сложных операций (макросы, сценарии)
* Скорость работы

## Типичные операции

* Навигация
    * По файлам
    * Перебор закладок
    * Боковая панель
    * Go to anything
    * Внутри файлов
        * Хождение по словам, строкам, экрану
        * Переход на строку
        * Переход между скобками
        * Go to symbol
* Выделение
    * Слов, Строк
    * Абзацев
    * Выражений внутри скобок
    * Всех вхождений слова => Поиск
* Поиск (и замена)
    * Простой поиск
        * Multiple cursor
        * Регулярные выражения
    * Инкрементальный
    * Быстрый
* Редактирование
    * Комментирование
    * Перестановка двух символов
    * Удаление: слов, строк, окончаний строк
    * Манипуляции со строками
        * Дублирование, переупорядочение, сортировка
        * Слияние и автоматический перенос
    * Редактирование нескольких строк и прямоугольных регионов

## Сравнительный анализ

### Atom

* Бесплатный
* Обширное количество packages(плагинов) для добавления дополнительного функционала
* Возможность кастомизации
* Подтормаживает при смене файлов или переключении вкладок

### Sublime

* Платный (но есть бесплатная версия)
* Большое количество packages, как в Atom
* Возможность кастомизации такие же как в Atom
* Гораздо шустрее Atom

### Visual Studio Code

* Бесплатный
* Много плагинов
* Встроенный Git
* Ничем не уступает в кастомизации
* Несмотря на то, что VS Code, как и Atom, созданы на базе Node.js, Electron, HTML, and CSS, VS Code достаточно быстр, в отличии от Atom

### Vim

* Бесплатный
* Более 14 000 packages – на все случаи жизни.
* Текстовый редактор в командной строке – может быть тяжел в освоении.
* Скорость работы, по большому счету, зависит от пользователя. Для быстрой работы нужно изучение большого количества горячих клавиш.
* Отлично кастомизируется.

### Emacs
* "Всё в одном"
    * Функциональность: базовая, основной режим, дополнительные режимы
* Расширяемость
    * Программируется на Elisp, имеются пакеты расширений,клавиатурные комбинации
* Настраиваемость под пользователя
    * Elisp-переменные, определение функций, создание hook'ов
* Документированность
    * Подробная документация, вплоть до функций и переменных
* Труден в освоении


## Инструменты отладки. Отладочная информация, терминология, популярные команды GDB.

**Отладка** - это процесс нахождения и устранения ошибок и дефектов в
    компьютерной программе или в электронном оборудовании.

**Отладчик** - это компьютерная программа, которая используется для
    тестирования и отладки других программ.

## Инструменты отладки

* **GDB**: GNU отладчик
* **Valgrind**: утилита для отладки проблем с памятью, утечек памяти и
    профилирования
* **strace**: трассирование системных вызовов
* **OProfile**: профилировщик для Linux систем

## Отладочная информация

* Информация, которую компилятор языка программирования генерирует автоматически на основе исходных кодов
* Специфичный кусок машинного кода, описывающий текущий исполняемый модуль
* Отладочная информация может компилироваться вместе с бинарным исполняемым файлом, и входить в его состав, может присутствовать в качестве отдельного файла, либо же просто отбрасываться на этапе компиляции и/или линковки
* Позволяет человеку использовать отладочные данные о двоичном файле, такие как имена переменных, процедур и функций из исходного кода
* Информация может быть крайне полезной во время поиска ошибок в исходном коде, отладке программы и разного рода отказах

* Содержит лог выполнения программы
* Позволяет выявить потенциально некорректные строки кода
* Указывает конкретные файл и строку в нем при некорректной работе программы

## Терминология

### Breakpoint

__Breakpoint__ (точка останова) - это преднамеренное прерывание выполнения программы, при котором выполняется вызов отладчика.

Типы точек останова:

* Точка останова с поддержкой аппаратуры
* Точка останова реализованная программно

Примеры команд для GDB: break, rbreak, tbreak

### Watchpoint

__Watchpoint__ - точка останова по данным. Срабатывает, когда меняется значение заданного выражения или переменной.

Примеры команд для GDB: watch, rwatch, awatch

### Checkpoint

__Checkpoint__ - снимок состояния программы.

Плюсы:

* Возможность начать отладку с определенной точки
* Иногда можно откатить операции ввода/вывода
* Можно обойти проблемы с рандомизацией адресного пространства в системах GNU Linux

Минусы:

* Не подходит для многопоточной программы
* Меняется идентификатор отлаживаемого процесса
* Действия с вводом/выводом нельзя отменить полностью

### Catchpoint

__Catchpoint__ - специальная точка останова, которая срабатывает при достижении специального события, например, C++ исключения или загрузки библиотеки.

Примеры команд для GDB: catch throw, catch catch, catch syscall, catch load.

### Call stack

__Call stack__ (стек вызовов) - хранит информацию об активных процедурах и функциях.

## Популярные команды GDB

* **`$ gdb --args <программа с аргументами>`**
* **`r, run [аргументы]`** - запуск программы под GDB
* **`start [аргументы]`** - удобный способ запуска программы с точкой останова на первой строчке функции `main`
* **`attach <pid> / detach`** - отладка уже запущенного процесса
* **`continue, c, fg`** - возобновление исполнения программы
* **`s, step [count]`** - продолжить исполнение до следующей строчки исходного кода
* **`n, next [count]`** - продолжить исполнение до следующей строчки исходного кода в текущем фрейме
* **`bt, backtrace [full] [n]`** - напечатать стек вызовов
* **`info args`** - вывести аргументы для текущего фрейма
* **`info locals`** - вывести локальные переменные для текущего 



# Билет №10
## История развития билд-систем (от shell до CMake и IDE).

## Вводная информация

* Исторически сложилось, что разработчики применяли автоматизацию сборки для вызова компиляторов и линковщиков из скрипта сборки, в отличие от вызова компилятора из командной строки
* Довольно просто при помощи командной строки передать один исходный модуль компилятору, а затем и линковщику для создания конечного объекта
* Однако, при попытке скомпилировать или слинковать множество модулей с исходным кодом, причём в определенном порядке, осуществление этого процесса вручную при помощи командной строки выглядит слишком неудобным
* Гораздо более привлекательной альтернативой является скриптовый язык, поддерживаемый утилитой Make
    * Данный инструмент позволяет писать скрипты сборки, определяя порядок их вызова, этапы компиляции и линковки для сборки программы.
    * GNU Make также предоставляет такие дополнительные возможности, как например, «зависимости» («makedepend»), которые позволяют указать условия подключения исходного кода на каждом этапе сборки
    * Это и стало началом автоматизации сборки.
    * Основной целью была автоматизация вызовов компиляторов и линковщиков
* По мере роста и усложнения процесса сборки разработчики начали добавлять действия до и после вызовов компиляторов, как например, проверку (check-out) версий копируемых объектов на тестовую систему
* Термин «автоматизация сборки» уже включает в себя управление и действия до и после компиляции и линковки, так же как и действия при компиляции и линковке.

## История

* shell скрипты

compile.sh:

```tbd
#!/bin/sh
cc -c main.c
cc -c lib.c
cc -o program main.o lib.o
```

* make, 1977 год

Makefile:

```tbd
OBJ = main.o lib.o
program: $(OBJ)
        cc -o program $(OBJ)
$(OBJ): defines.h
```

* Autotools
    * Было де-факто стандартом и до сих пор используется, но:
        * слишком сложно
        * только Unix
        * sh, m4
        * зависимости

Makefile.am:

```tbd
bin_PROGRAMS = hello
hello_SOURCES = main.c lib.c
```

configure.ac:

```tbd
AC_INIT([program], [1.0], [sample@mail.org])
AM_INIT_AUTOMAKE([-Wall -Werror foreign])
AC_PROG_CC
AC_CONFIG_HEADERS([config.h])
AC_CONFIG_FILES([
 Makefile
])
AC_OUTPUT
```

Для запуска:

```tbd
autoreconf --install
./configure
make
```

## CMake

    * Широкая поддержка разнообразных целевых платформ и IDE
    * Максимальная свобода в выборе окружения разработки (в рамках одной команды!)
    * В настоящий момент является стандартом де-факто для С++ проектов
    * Основной "недостаток" — собственный язык
    * Поначалу инструмент кажется нетривиальным, но очень удобен впоследствии
    * Дает членам команды максимальную свободу в выборе инструментов (OC, IDE или простой текстовый редактор)
    * Обеспечивает переносимость и является стандартом де-факто\
    для кросс-платформенных С++ проектов

### CMake workflow

* `CMakeLists.txt` — файл, описывающий порядок сборки приложения
* Плохая практика хранить все файлы (в том числе и исполняемые) в одной директории
* Хорошая практика - располагать файлы по директориям src, include, build, test и т.д.



## UNIX. Философия и преимущества при автоматизации.

## Философия UNIX

* Пишите программы, выполняющие одну задачу и выполняющие ее хорошо (Write programs that do one thing and do it well)
* Пишите программы для совместной работы (Write programs to work together)
* Пишите программы, обрабатывающие/использующие текстовые потоки, так как текстовые потоки - универсальный интерфейс (Write programs to handle text streams, because that is a universal interface)

## Преимущества при автоматизации

* Огромное количество утилит на любой случай жизни (find, cron, tar, sed, и т.д.)
* Вместе со скриптовыми языками (Bash, Perl, Python, etc) предоставляет широчайшие возможности для автоматизации



# Билет №11
## Различные рабочие процессы в Git (workflow). Назначение, плюсы и минусы каждого из вариантов.

## Feature branches

![](./pictures/topic-branches-1.png)

* Для каждой более-менее крупной фичи создается отдельная ветка, на которой она разрабатывается параллельно основной разработке проекта. Затем фича вливается в ветку development или сразу в master

## GitFlow

![](./pictures/git-flow-updated.png)

### Пояснения к схеме

* Есть две основные ветки: master и develop.
* В ветке master содержится ровно тот же код, что и в рабочей версии проекта. А вся работа делается в ветке develop.
* Во время работы на основе develop создаются так называемые feature-ветки. Их может быть неограниченное количество.
* Далее, у нас есть ветка release, которая используется для подготовки к новому релизу проекта.
* Наконец, есть ветка hotfix, которая служит для срочного исправления багов, найденных, например, на продакте.

### Рабочий процесс в Gitflow

1. Создается репозиторий
2. Репозиторий инициализируется
3. Начинается работа на ветке develop
4. Возникает необходимость опробовать новую штуку – создается feature-ветка и делаются коммиты
5. Закончив работу на feature-ветке, вы сливаете ее с develop
6. Если вы довольны текущей версией, но хотите продолжить работу, создается ветка release, куда перемещается текущая версия. Правка багов будет происходить на этой же ветке.
7. Когда с веткой release покончено, время слить ее в master и продолжить работу с develop
8. Кроме того, этот момент можно отметить на master-ветке

## GitHub Flow

![](./pictures/github-flow.png)

### Рабочий процесс в GitHub

* Содержимое ветви master всегда работоспособно (deployable).
* Начиная работу над чем-то новым, ответвляйте от ветви master новую ветвь, имя которой соответствует её предназначению (например, «new-oauth2-scopes»).
* Закоммитив в эту ветвь локально, отправляйте регулярно свою работу и в одноимённую ветвь на сервере.
* Когда вам понадобится отзыв, или помощь, или когда вы сочтёте ветвь готовою ко слиянию, отправьте запрос на слияние.
* После того, как кто-то другой просмотрел и одобрил фичу, вы можете слить вашу ветвь в ветвь master.
* После того, как ветвь master пополнилась новым кодом, вы можете немедленно внедрить его на продакшен и вам следует сделать это.

## Распределенные рабочие процессы (workflow)

## Centralized
![](./pictures/centralized-workflow.png)

* Существует один репозиторий, в который каждый разработчик имеет право заливать изменения прямо в ветку master
* Состоятелен для маленьких команд (<10 человек), особенно если все разработчики находятся в одном помещении
* Главным минусом подхода являются merge conflicts, ситуации, когда одни и те же файлы были изменены разными разработчиками и один и тот же файл пытаются залить в master

## Integration Manager
![](./pictures/integration-manager-workflow.png)

* Подходит для больших и средних команд
* Каждый разрботчик имеет свою копию главного репозитория, в которую только он может заливать файлы
* Для внесения изменений в главный репозиторий разработчик посылает пулл запрос
* Пулл запрос рецензируется integration manager'ом и другими разработчиками
* После получения одобрения от integration manager'а изменения вливаются в ветку master
* Merge conflict крайне маловероятны благодаря наличию integration manager'а
* Пулл запросы могут проверяться значительное время в зависимости от загруженности integration manager'а
* Крайне важен выбор integration manager'а 

## Dictator and Lieutenants
![](./pictures/dictator-and-lieutenants-orkflow.png)

* Идеально подходит для open-source проектов с главенствующей ролью создателя проекта
* Является расширением integration manager workflow
* В проекте выделяется диктатор с эксклюзивными правами записи в главный репозиторий, и лейтенанты, контролирующие отдельные аспекты проекта
* Разработчики посылают изменения на проверку лейтенантам
* После одобрения изменений лейтенанты посылают эти изменения диктатору на одобрение
* Плюсом является крайняя степнь контроля качества проекта
* Минусом - процесс проверки и одобрения изменений может сильно затянуться

## Статическая и динамическая компоновка. Сравнительный анализ.

## Статическая компоновка

* Готовится исходный текст приложения
* Затем транслируется для получения объектного модуля
* После этого редактор связей компонует объектные модули, полученные в результате трансляции исходных текстов и модули из библиотек объектных модулей, в один исполняемый файл
    * В файл записываются все модули, необходимые для работы
* В процессе запуска файл программы загружается полностью в оперативную память и ему передавается управление.
    * В любой момент времени в оперативной памяти компьютера находится весь код, необходимый для работы запущенной программы
* Все функции находятся внутри выполняемого модуля;
* Все адреса переменных и функций определяются на этапе компиляции;
* "Нет зависимости" от других библиотек.

Недостатки:

* Неэкономное использование оперативной памяти.

## Динамическая компоновка

* Загрузочный код нескольких функций объединяется в отдельные файлы, загружаемые в оперативную память в единственном экземпляре
    * В загрузочном файле программы можно расположить только те функции, которые являются специфическими для данной программы
    * Функции, необходимые всем (или многим) программам, работающим параллельно,выносятся в библиотеки динамической компоновки, и хранятся в памяти в единственном экземпляре
* Программы, работающие параллельно, вызывают функции, загруженные в память из файлов библиотек динамической компоновки, а не из файлов программ

* Компоновка исполняемого модуля во время исполнения;
* Библиотечные функции находятся в других модулях;
* Связывание происходит во время выполнения путём заполнения таблиц адресов;
* Явная зависимость от других библиотек.



# Билет №12
## СКВ. Определение, назначение, история развития (преимущества DVCS).

__Системы контроля версий__ — это программные системы, хранящие несколько версий одного документа, и позволяющие вернуться к более ранним версиям. Как правило, для каждого изменения запоминается дата модификации и автор.
 
## Локальные системы контроля версий

![](./pictures/local-vcs.png)

* До появления полноценных СКВ в качестве метода контроля версий применяется копирование файлов в отдельную директорию
    * возможно даже, директорию с отметкой по времени
* Данный подход очень распространён из-за его простоты
    * невероятно сильно подвержен появлению ошибок
        * можно легко забыть, в какой директории вы находитесь
        * случайно изменить не тот файл
        * скопировать не те файлы


Для решения этой проблемы были разработаны __локальные СКВ__ с простой базой данных, которая хранит записи о всех изменениях в файлах, осуществляя тем самым контроль ревизий.

Однако организация одновременной работы в локальных СКВ возможна лишь при __полной недоступности изменяемых файлов__ для других разработчков.

Пример локальной СКВ - __RCS__:

* на сегодняшний день  распространяется со многими компьютерами
    * Даже Mac OS X предоставляет команду rcs, после установки Developer Tools
* RCS хранит на диске наборы патчей (различий между файлами) в специальном формате, применяя которые она может воссоздавать состояние каждого файла в заданный момент времени.

## Централизованные системы контроля версий

![](./pictures/centralized-vcs.png)

* __Централизованные системы контроля версий__ (ЦСКВ) были разработаны для устранения проблемы взаимодействия с другими разработчиками во время разработки

* Такие системы, как: CVS, Subversion и Perforce, имеют единственный сервер, содержащий все версии файлов, и некоторое количество клиентов, которые получают файлы из этого централизованного хранилища
* ЦСКВ являлась стандартом на протяжении многих лет.

Организация одновременной работы: merge before commit

### Преимущества (в сравнении в ЛСКВ)

* все разработчики проекта в определённой степени знают, чем занимается каждый из них
* администраторы имеют полный контроль над тем, кто и что может делать

### Недостатки ЦСКВ
* вся история проекта хранится в одном месте
    * риск потерять всё
* единая точка отказа, представленная централизованным сервером
    * если сервер выйдет из строя, то в течение этого времени никто не сможет использовать контроль версий для сохранения изменений, над которыми он работает, а также никто не сможет обмениваться этими изменениями с другими разработчиками
* Если жёсткий диск, на котором хранится центральная БД, повреждён, а своевременные бэкапы отсутствуют, все данные теряются
    * не считая единичных снимков репозитория, которые сохранились на локальных машинах разработчиков.

## Децентрализованные системы контроля версий

![](./pictures/distributed-vcs.png)

* В ДСКВ (таких как Git, Mercurial, Bazaar или Darcs), клиенты не просто скачивают снимок всех файлов (состояние файлов на определённый момент времени): они полностью копируют репозиторий.
* если один из серверов, через который разработчики обменивались данными, умрёт, любой клиентский репозиторий может быть скопирован на другой сервер для продолжения работы.
* Каждая копия репозитория является полным бэкапом всех данных.
* многие ДСКВ могут одновременно взаимодействовать с несколькими удалёнными репозиториями
    * возможность работать с различными группами людей, применяя различные подходы единовременно, в рамках одного проекта
* позволяет применять сразу несколько подходов в разработке

### Преимущества

* Допускают локальную работу (коммиты без наличия интернет)
* Упрощают слияние (а значит параллельную разработку)
* Дают максимальную свободу по организации рабочего процесса (workflow)

## CMake. Назначение, возможности, плюсы и минусы.

__CMake__ (от англ. cross platform make) — это кроссплатформенная система автоматизации сборки программного обеспечения из исходного кода.

CMake не занимается непосредственно сборкой, a лишь генерирует файлы управления сборкой из файлов CMakeLists.txt.

### Достоинства

* Широкая поддержка разнообразных целевых платформ и IDE
* Максимальная свобода в выборе окружения разработки (в рамках одной команды!)
* В настоящий момент является стандартом де-факто для С++ проектов
* Дает членам команды максимальную свободу в выборе инструментов (OC, IDE или    простой текстовый редактор)
* Обеспечивает переносимость
* Поначалу инструмент кажется нетривиальным, но очень удобен впоследствии

### Недостатки

* Основной "недостаток" — собственный язык

### CMake Workflow

* Компиляция исходников при помощи компиляторов из Visual Studio, Qt Creator, Eclipse, XCode
    * .obj, .o
* Линковка финальных бинарных файлов компоновщиком (link.exe, ld, ...) 
    * .exe, .dll, .lib, .a, .so, .dylib



# Билет №13
## Современная стратегия тестирования (распределение ролей и инструментальная поддержка).

* Без "зеленых" тестов нет уверенности в работоспособности кода
* Фокус на максимальную автоматизацию
    * Полное тестирование требуется несколько раз в день, каждому члену команды
* Тесты пишутся самими разработчиками, одновременно с реализацией
    * Тесты это лучшая документация, которая всегда актуальна
    * Тесты это первые сэмплы, показывающие простые примеры использования
    * Test-Driven Development
* Код тестируется непрерывно
    * Это делается локально на машине разработчика
    * Это делается на сервере до того, как добавить его в репозиторий
* Автоматические тесты замещают отладку
    * Предсказуемость времени разработки
    * Пойманный баг документируется в виде теста
* Тесты — это "first-class citizens"
    * Стоит отдавать код вместе с тестами
    * Нужно заботиться о качестве кода тестов
    * Метафора тестов: скелет, позволяющий организму двигаться

## Учет и планирование задач

## Scrum

![](./pictures/sprint-lifecycle.png)

## Google Docs

![](./pictures/backlog.png)

* В облаке с совместным редактированием создается файл, который заполняется текущими задачами, распределенными по важности и времени выполнения, а так же указывается ответственный за эту задачу. 
* Однако, приходится вручную изменять документ, указывая о готовых изменениях.

## GitHub Issues (проблемы / задачи)

![](./pictures/github-issues.png)

 __Issues__ - отличный способ отслеживать задачи, улучшения и ошибки для ваших проектов

* Они вроде как электронная почта, за исключением того, что они могут делиться и обсуждаться с остальной частью вашей команды
* В большинстве программных проектов есть какой-то трекер ошибок
    * Трекер GitHub называется «Issues» и имеет свой раздел в каждом репозитории

### Отслеживание проблем GitHub

* Название и описание описывают суть проблемы
* Цветные ярлыки позволяют классифицировать и фильтровать ваши проблемы (так же, как метки в электронной почте)
* Milestone действует как контейнер для вопросов
    * Это полезно для связывания вопросов со специфическими особенностями или этапами проекта
* Один цессионарий несет ответственность за работу над проблемой в любой момент времени
* Комментарии позволяют любому, кто имеет доступ к репозиторию, предоставлять обратную связь


## GitHub Milestones

![](./pictures/github-roadmap.png)

__Milestones__ — это группы проблем, которые соответствуют проекту, функции или периоду времени

Люди используют их разными способами в разработке программного обеспечения

Вехи в GitHub:

* Beta Launch - Ошибки файлов, которые необходимо исправить, прежде чем вы сможете запустить бета-версию вашего проекта
    * отличный способ убедиться, что вы ничего не пропустили
* Month Sprint - проблемы с файлами, с которыми вы хотели бы работать в опреденном месяце
    * Отличный способ сосредоточить свои усилия, когда вам предстоит многое сделать.
* Редизайн - проблемы с файлами, связанные с перепроектированием проекта
    * Отличный способ собрать идеи о том, над чем работать.

## GitHub Labels

__Labels__ - отличный способ организовать различные типы проблем. 

Проблемы могут иметь столько label-ов, сколько вы хотите, и вы можете фильтровать один или несколько ярлыков одновременно.

## Assignees

В каждом issue может быть __assign__ - один человек, который несет ответственность за продвижение проблемы.

Выделенные лица выбираются так же, как и Milestone, через серый бар в верхней части проблемы.

## Redmine Roadmap

![](./pictures/redmine-roadmap.png)

В __Roadmap__ представлен высоко настраиваемый, основанный на версии вид системы отслеживания проблем, которая помогает планировать и управлять разработкой проекта. 

* Он также содержит подробный (основанный на версии) обзор текущего состояния вашего проекта.
* Roadmap предоставляет обзор текущего состояния проекта

### Обзор текущего состояния проекта содержит

* название версии
* дата, когда версия будет завершена
* индикатор выполнения, который показывает общее соотношение «активное / сделанное / закрытое» на основе% -done, расчетное время и статусы проблем, предназначенных для соответствующей версии, визуализированных разными цветовыми градиентами
    * включает ссылки на список проблем, которые предварительно загружают конкретные фильтры, обеспечивая тем самым быстрые ссылки на открытые / закрытые проблемы, предназначенные для соответствующей версии
* если сконфигурировано: содержимое вики-страницы, которая была настроена для присоединения к версии (см. ниже)
* если настроено: список всех проблем, связанных с конкретной версией 

Процент завершения версии использует приблизительное время для каждой проблемы.

Вопросы без расчетного времени взвешиваются со средним расчетным временем.

Если ни одна проблема не оценивается, они получают одинаковый вес.
