# Билет №11
## Различные рабочие процессы в Git (workflow). Назначение, плюсы и минусы каждого из вариантов.

## Feature branches

![](./pictures/topic-branches-1.png)

* Для каждой более-менее крупной фичи создается отдельная ветка, на которой она разрабатывается параллельно основной разработке проекта. Затем фича вливается в ветку development или сразу в master

## GitFlow

![](./pictures/git-flow-updated.png)

### Пояснения к схеме

* Есть две основные ветки: master и develop.
* В ветке master содержится ровно тот же код, что и в рабочей версии проекта. А вся работа делается в ветке develop.
* Во время работы на основе develop создаются так называемые feature-ветки. Их может быть неограниченное количество.
* Далее, у нас есть ветка release, которая используется для подготовки к новому релизу проекта.
* Наконец, есть ветка hotfix, которая служит для срочного исправления багов, найденных, например, на продакте.

### Рабочий процесс в Gitflow

1. Создается репозиторий
2. Репозиторий инициализируется
3. Начинается работа на ветке develop
4. Возникает необходимость опробовать новую штуку – создается feature-ветка и делаются коммиты
5. Закончив работу на feature-ветке, вы сливаете ее с develop
6. Если вы довольны текущей версией, но хотите продолжить работу, создается ветка release, куда перемещается текущая версия. Правка багов будет происходить на этой же ветке.
7. Когда с веткой release покончено, время слить ее в master и продолжить работу с develop
8. Кроме того, этот момент можно отметить на master-ветке

## GitHub Flow

![](./pictures/github-flow.png)

### Рабочий процесс в GitHub

* Содержимое ветви master всегда работоспособно (deployable).
* Начиная работу над чем-то новым, ответвляйте от ветви master новую ветвь, имя которой соответствует её предназначению (например, «new-oauth2-scopes»).
* Закоммитив в эту ветвь локально, отправляйте регулярно свою работу и в одноимённую ветвь на сервере.
* Когда вам понадобится отзыв, или помощь, или когда вы сочтёте ветвь готовою ко слиянию, отправьте запрос на слияние.
* После того, как кто-то другой просмотрел и одобрил фичу, вы можете слить вашу ветвь в ветвь master.
* После того, как ветвь master пополнилась новым кодом, вы можете немедленно внедрить его на продакшен и вам следует сделать это.

## Распределенные рабочие процессы (workflow)

## Centralized
![](./pictures/centralized-workflow.png)

* Существует один репозиторий, в который каждый разработчик имеет право заливать изменения прямо в ветку master
* Состоятелен для маленьких команд (<10 человек), особенно если все разработчики находятся в одном помещении
* Главным минусом подхода являются merge conflicts, ситуации, когда одни и те же файлы были изменены разными разработчиками и один и тот же файл пытаются залить в master

## Integration Manager
![](./pictures/integration-manager-workflow.png)

* Подходит для больших и средних команд
* Каждый разрботчик имеет свою копию главного репозитория, в которую только он может заливать файлы
* Для внесения изменений в главный репозиторий разработчик посылает пулл запрос
* Пулл запрос рецензируется integration manager'ом и другими разработчиками
* После получения одобрения от integration manager'а изменения вливаются в ветку master
* Merge conflict крайне маловероятны благодаря наличию integration manager'а
* Пулл запросы могут проверяться значительное время в зависимости от загруженности integration manager'а
* Крайне важен выбор integration manager'а 

## Dictator and Lieutenants
![](./pictures/dictator-and-lieutenants-orkflow.png)

* Идеально подходит для open-source проектов с главенствующей ролью создателя проекта
* Является расширением integration manager workflow
* В проекте выделяется диктатор с эксклюзивными правами записи в главный репозиторий, и лейтенанты, контролирующие отдельные аспекты проекта
* Разработчики посылают изменения на проверку лейтенантам
* После одобрения изменений лейтенанты посылают эти изменения диктатору на одобрение
* Плюсом является крайняя степнь контроля качества проекта
* Минусом - процесс проверки и одобрения изменений может сильно затянуться

## Статическая и динамическая компоновка. Сравнительный анализ.

## Статическая компоновка

* Готовится исходный текст приложения
* Затем транслируется для получения объектного модуля
* После этого редактор связей компонует объектные модули, полученные в результате трансляции исходных текстов и модули из библиотек объектных модулей, в один исполняемый файл
    * В файл записываются все модули, необходимые для работы
* В процессе запуска файл программы загружается полностью в оперативную память и ему передавается управление.
    * В любой момент времени в оперативной памяти компьютера находится весь код, необходимый для работы запущенной программы
* Все функции находятся внутри выполняемого модуля;
* Все адреса переменных и функций определяются на этапе компиляции;
* "Нет зависимости" от других библиотек.

Недостатки:

* Неэкономное использование оперативной памяти.

## Динамическая компоновка

* Загрузочный код нескольких функций объединяется в отдельные файлы, загружаемые в оперативную память в единственном экземпляре
    * В загрузочном файле программы можно расположить только те функции, которые являются специфическими для данной программы
    * Функции, необходимые всем (или многим) программам, работающим параллельно,выносятся в библиотеки динамической компоновки, и хранятся в памяти в единственном экземпляре
* Программы, работающие параллельно, вызывают функции, загруженные в память из файлов библиотек динамической компоновки, а не из файлов программ

* Компоновка исполняемого модуля во время исполнения;
* Библиотечные функции находятся в других модулях;
* Связывание происходит во время выполнения путём заполнения таблиц адресов;
* Явная зависимость от других библиотек.
